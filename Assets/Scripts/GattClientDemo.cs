using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using TMPro;
using UnityEngine;

// This class contains all Bluetooth Framework error codes (copied from .NET Edition).
// You can find more information about error codes (full description)
// on our site: https://www.btframework.com/errors.htm
public class BluetoothErrors
{
    public const Int32 WCL_E_SUCCESS = 0x00000000;

    public const Int32 WCL_E_BASE = 0x00010000;
    public const Int32 WCL_E_INVALID_ARGUMENT = WCL_E_BASE + 0x0000;
    public const Int32 WCL_E_OUT_OF_MEMORY = WCL_E_BASE + 0x0001;
    public const Int32 WCL_E_THREAD_RUNNING = WCL_E_BASE + 0x0002;
    public const Int32 WCL_E_UNABLE_CREATE_THREAD_INIT_EVENT = WCL_E_BASE + 0x0003;
    public const Int32 WCL_E_UNABLE_CREATE_THREAD = WCL_E_BASE + 0x0004;
    public const Int32 WCL_E_THREAD_NOT_RUNNING = WCL_E_BASE + 0x0005;
    public const Int32 WCL_E_THREAD_SIGNAL_FAILED = WCL_E_BASE + 0x0006;
    public const Int32 WCL_E_THREAD_MESSAGE_REGISTRATION_FAILED = WCL_E_BASE + 0x0007;
    public const Int32 WCL_E_THREAD_WINDOW_CREATION_FAILED = WCL_E_BASE + 0x0008;
    public const Int32 WCL_E_THREAD_INITIALIZATION_FAILED = WCL_E_BASE + 0x0009;

    public const Int32 WCL_E_MR_BASE = WCL_E_BASE + 0x1000;
    public const Int32 WCL_E_MR_CLOSED = WCL_E_MR_BASE + 0x0000;
    public const Int32 WCL_E_MR_OPENED = WCL_E_MR_BASE + 0x0001;
    public const Int32 WCL_E_MR_NOT_OPENED = WCL_E_MR_BASE + 0x0002;
    public const Int32 WCL_E_MR_UNABLE_SYNCHRONIZE = WCL_E_MR_BASE + 0x0003;
    public const Int32 WCL_E_MR_UNABLE_REGISTER_SYNC_OBJ = WCL_E_MR_BASE + 0x0004;
    public const Int32 WCL_E_MR_UNABLE_CREATE_SYNC_OBJ = WCL_E_MR_BASE + 0x0005;
    public const Int32 WCL_E_MR_SYNC_OBJ_NOT_CREATED = WCL_E_MR_BASE + 0x0006;

    public const Int32 WCL_E_MB_BASE = WCL_E_BASE + 0x2000;
    public const Int32 WCL_E_MB_RECEIVER_ALREADY_SUBSCRIBED = WCL_E_MB_BASE + 0x0000;
    public const Int32 WCL_E_MB_RECEIVER_NOT_SUBSCRIBED = WCL_E_MB_BASE + 0x0001;
    public const Int32 WCL_E_MB_CAN_NOT_INIT_HW_THREAD = WCL_E_MB_BASE + 0x0002;
    public const Int32 WCL_E_MB_CAN_NOT_START_HW_THREAD = WCL_E_MB_BASE + 0x0003;
    public const Int32 WCL_E_MB_UNABLE_CREATE_HW_OBJ = WCL_E_MB_BASE + 0x0004;
    public const Int32 WCL_E_MB_UNABLE_REGISTER_HW_NOTIFY = WCL_E_MB_BASE + 0x0005;
    public const Int32 WCL_E_MB_UNABLE_CREATE_MUTEX = WCL_E_MB_BASE + 0x0006;
    public const Int32 WCL_E_MB_NOT_CREATED = WCL_E_MB_BASE + 0x0007;
    public const Int32 WCL_E_MB_REF_COUNT_ERROR = WCL_E_MB_BASE + 0x0008;
    public const Int32 WCL_E_MB_RUNNING = WCL_E_MB_BASE + 0x0009;

    public const Int32 WCL_E_WINRT_BASE = WCL_E_BASE + 0x3000;
    public const Int32 WCL_E_WINRT_UNABLE_CREATE_MUTEX = WCL_E_WINRT_BASE + 0x0000;
    public const Int32 WCL_E_WINRT_UNABLE_LOAD_CORE_DLL = WCL_E_WINRT_BASE + 0x0001;
    public const Int32 WCL_E_WINRT_UNABLE_LOAD_STRING_DLL = WCL_E_WINRT_BASE + 0x0002;
    public const Int32 WCL_E_WINRT_INIT_FAILED = WCL_E_WINRT_BASE + 0x0003;
    public const Int32 WCL_E_WINRT_UNABLE_CREATE_STRING = WCL_E_WINRT_BASE + 0x0004;
    public const Int32 WCL_E_WINRT_UNABLE_ACTIVATE_INSTANCE = WCL_E_WINRT_BASE + 0x0005;
    public const Int32 WCL_E_WINRT_UNABLE_CREATE_INTERFACE = WCL_E_WINRT_BASE + 0x0006;
    public const Int32 WCL_E_WINRT_ASYNC_OPERATION_FAILED = WCL_E_WINRT_BASE + 0x0007;
    public const Int32 WCL_E_WINRT_ASYNC_OPERATION_CANCELLED = WCL_E_WINRT_BASE + 0x0008;
    public const Int32 WCL_E_WINRT_ASYNC_OPERATION_ERROR = WCL_E_WINRT_BASE + 0x0009;
    public const Int32 WCL_E_WINRT_DETACH_BUFFER_FAILED = WCL_E_WINRT_BASE + 0x000A;

    public const Int32 WCL_E_CONNECTION_BASE = 0x00030000;
    public const Int32 WCL_E_CONNECTION_ACTIVE = WCL_E_CONNECTION_BASE + 0x0000;
    public const Int32 WCL_E_CONNECTION_NOT_ACTIVE = WCL_E_CONNECTION_BASE + 0x0001;
    public const Int32 WCL_E_CONNECTION_UNABLE_CREATE_TERMINATE_EVENT = WCL_E_CONNECTION_BASE + 0x0002;
    public const Int32 WCL_E_CONNECTION_UNABLE_CREATE_CONNECTION_COMPLETE_EVENT = WCL_E_CONNECTION_BASE + 0x0003;
    public const Int32 WCL_E_CONNECTION_UNABLE_START_COMMUNICATION = WCL_E_CONNECTION_BASE + 0x0004;
    public const Int32 WCL_E_CONNECTION_TERMINATED = WCL_E_CONNECTION_BASE + 0x0005;
    public const Int32 WCL_E_CONNECTION_TERMINATED_BY_USER = WCL_E_CONNECTION_BASE + 0x0006;
    public const Int32 WCL_E_CONNECTION_UNABLE_CREATE_INIT_EVENT = WCL_E_CONNECTION_BASE + 0x0007;
    public const Int32 WCL_E_CONNECTION_CLOSED = WCL_E_CONNECTION_BASE + 0x0008;
    public const Int32 WCL_E_CONNECTION_UNEXPECTED = WCL_E_CONNECTION_BASE + 0x0009;
    public const Int32 WCL_E_CONNECTION_UNABLE_CREATE_OR_INIT_CLIENT = WCL_E_CONNECTION_BASE + 0x000A;
    public const Int32 WCL_E_CONNECTION_UNABLE_FIND_CLIENT_CLASS = WCL_E_CONNECTION_BASE + 0x000B;

    public const Int32 WCL_E_OBEX_BASE = WCL_E_CONNECTION_BASE + 0x1000;
    public const Int32 WCL_E_OBEX_NOT_CONNECTED = WCL_E_OBEX_BASE + 0x0000;
    public const Int32 WCL_E_OBEX_CONNECTED = WCL_E_OBEX_BASE + 0x0001;
    public const Int32 WCL_E_OBEX_OPERATION_IN_PROGRESS = WCL_E_OBEX_BASE + 0x0002;
    public const Int32 WCL_E_OBEX_CONTINUE = WCL_E_OBEX_BASE + 0x0003;
    public const Int32 WCL_E_OBEX_CREATED = WCL_E_OBEX_BASE + 0x0004;
    public const Int32 WCL_E_OBEX_ACCEPTED = WCL_E_OBEX_BASE + 0x0005;
    public const Int32 WCL_E_OBEX_NON_AUTHORITATIVE = WCL_E_OBEX_BASE + 0x0006;
    public const Int32 WCL_E_OBEX_NO_CONTENT = WCL_E_OBEX_BASE + 0x0007;
    public const Int32 WCL_E_OBEX_RESET_CONTENT = WCL_E_OBEX_BASE + 0x0008;
    public const Int32 WCL_E_OBEX_PARTIAL_CONTENT = WCL_E_OBEX_BASE + 0x0009;
    public const Int32 WCL_E_OBEX_MULTIPLE_CHOICES = WCL_E_OBEX_BASE + 0x000A;
    public const Int32 WCL_E_OBEX_MOVED_PERMANENTLY = WCL_E_OBEX_BASE + 0x000B;
    public const Int32 WCL_E_OBEX_MOVED_TEMPORARY = WCL_E_OBEX_BASE + 0x000C;
    public const Int32 WCL_E_OBEX_SEE_OTHER = WCL_E_OBEX_BASE + 0x000D;
    public const Int32 WCL_E_OBEX_NOT_MODIFIED = WCL_E_OBEX_BASE + 0x000E;
    public const Int32 WCL_E_OBEX_USE_PROXY = WCL_E_OBEX_BASE + 0x000F;
    public const Int32 WCL_E_OBEX_BAD_REQUEST = WCL_E_OBEX_BASE + 0x0010;
    public const Int32 WCL_E_OBEX_UNAUTHORIZED = WCL_E_OBEX_BASE + 0x0011;
    public const Int32 WCL_E_OBEX_PAYMENT_REQUIRED = WCL_E_OBEX_BASE + 0x0012;
    public const Int32 WCL_E_OBEX_FORBIDDEN = WCL_E_OBEX_BASE + 0x0013;
    public const Int32 WCL_E_OBEX_NOT_FOUND = WCL_E_OBEX_BASE + 0x0014;
    public const Int32 WCL_E_OBEX_METHOD_NOT_ALLOWED = WCL_E_OBEX_BASE + 0x0015;
    public const Int32 WCL_E_OBEX_NOT_ACCEPTABLE = WCL_E_OBEX_BASE + 0x0016;
    public const Int32 WCL_E_OBEX_PROXY_AUTH_REQUIRED = WCL_E_OBEX_BASE + 0x0017;
    public const Int32 WCL_E_OBEX_REQUEST_TIMEOUT = WCL_E_OBEX_BASE + 0x0018;
    public const Int32 WCL_E_OBEX_CONFLICT = WCL_E_OBEX_BASE + 0x0019;
    public const Int32 WCL_E_OBEX_GONE = WCL_E_OBEX_BASE + 0x001A;
    public const Int32 WCL_E_OBEX_LENGTH_REQUIRED = WCL_E_OBEX_BASE + 0x001B;
    public const Int32 WCL_E_OBEX_PRECONDITION_FAILED = WCL_E_OBEX_BASE + 0x001C;
    public const Int32 WCL_E_OBEX_REQUEST_TOO_LARGE = WCL_E_OBEX_BASE + 0x001D;
    public const Int32 WCL_E_OBEX_URL_TOO_LARGE = WCL_E_OBEX_BASE + 0x001E;
    public const Int32 WCL_E_OBEX_UNSUPPORTED_MEDIA_TYPE = WCL_E_OBEX_BASE + 0x001F;
    public const Int32 WCL_E_OBEX_INTERNAL = WCL_E_OBEX_BASE + 0x0020;
    public const Int32 WCL_E_OBEX_NOT_IMPLEMENTED = WCL_E_OBEX_BASE + 0x0021;
    public const Int32 WCL_E_OBEX_BAD_GATEWAY = WCL_E_OBEX_BASE + 0x0022;
    public const Int32 WCL_E_OBEX_SERVICE_UNAVAILABLE = WCL_E_OBEX_BASE + 0x0023;
    public const Int32 WCL_E_OBEX_GATEWAY_TIMEOUT = WCL_E_OBEX_BASE + 0x0024;
    public const Int32 WCL_E_OBEX_HTTP_VERSION_NOT_SUPPORTED = WCL_E_OBEX_BASE + 0x0025;
    public const Int32 WCL_E_OBEX_DATABASE_FULL = WCL_E_OBEX_BASE + 0x0026;
    public const Int32 WCL_E_OBEX_DATABASE_LOCKED = WCL_E_OBEX_BASE + 0x0027;
    public const Int32 WCL_E_OBEX_OPERATION_TERMINATED_BY_DISCONNECT = WCL_E_OBEX_BASE + 0x0028;
    public const Int32 WCL_E_OBEX_OPERATION_TERMINATED_BY_USER = WCL_E_OBEX_BASE + 0x0029;
    public const Int32 WCL_E_OBEX_INVALID_OPERATION_SEQUENCE = WCL_E_OBEX_BASE + 0x002A;
    public const Int32 WCL_E_OBEX_DISCONNECTED = WCL_E_OBEX_BASE + 0x002B;
    public const Int32 WCL_E_OBEX_UNEXPECTED = WCL_E_OBEX_BASE + 0x002C;
    public const Int32 WCL_E_OBEX_CREATE_CONNECTION_ID_MUTEX_FAILED = WCL_E_OBEX_BASE + 0x002D;
    public const Int32 WCL_E_OBEX_MAX_CONNECTION_ID = WCL_E_OBEX_BASE + 0x002E;
    public const Int32 WCL_E_OBEX_INVALID_STATE = WCL_E_OBEX_BASE + 0x002F;

    public const Int32 WCL_E_BLUETOOTH_BASE = 0x00050000;
    public const Int32 WCL_E_BLUETOOTH_MANAGER_CLOSED = WCL_E_BLUETOOTH_BASE + 0x0000;
    public const Int32 WCL_E_BLUETOOTH_MANAGER_OPENED = WCL_E_BLUETOOTH_BASE + 0x0001;
    public const Int32 WCL_E_BLUETOOTH_MANAGER_OPEN_FAILED = WCL_E_BLUETOOTH_BASE + 0x0002;
    public const Int32 WCL_E_BLUETOOTH_MANAGER_EXISTS = WCL_E_BLUETOOTH_BASE + 0x0003;
    public const Int32 WCL_E_BLUETOOTH_DRIVER_NOT_AVAILABLE = WCL_E_BLUETOOTH_BASE + 0x0004;
    public const Int32 WCL_E_BLUETOOTH_HARDWARE_NOT_AVAILABLE = WCL_E_BLUETOOTH_BASE + 0x0005;
    public const Int32 WCL_E_BLUETOOTH_API_NOT_LOADED = WCL_E_BLUETOOTH_BASE + 0x0006;
    public const Int32 WCL_E_BLUETOOTH_API_INITIALIZATION_FAILED = WCL_E_BLUETOOTH_BASE + 0x0007;
    public const Int32 WCL_E_BLUETOOTH_API_NOT_FOUND = WCL_E_BLUETOOTH_BASE + 0x0008;
    public const Int32 WCL_E_BLUETOOTH_API_NOT_INITIALIZED = WCL_E_BLUETOOTH_BASE + 0x0009;
    public const Int32 WCL_E_BLUETOOTH_WRONG_DRIVER_VERSION = WCL_E_BLUETOOTH_BASE + 0x000A;
    public const Int32 WCL_E_BLUETOOTH_RADIO_OPENED = WCL_E_BLUETOOTH_BASE + 0x000B;
    public const Int32 WCL_E_BLUETOOTH_RADIO_CLOSED = WCL_E_BLUETOOTH_BASE + 0x000C;
    public const Int32 WCL_E_BLUETOOTH_RADIO_REMOVED = WCL_E_BLUETOOTH_BASE + 0x000D;
    public const Int32 WCL_E_BLUETOOTH_RADIO_INSTANCE_INIT_FAILED = WCL_E_BLUETOOTH_BASE + 0x000E;
    public const Int32 WCL_E_BLUETOOTH_RADIO_INSTANCE_EXISTS = WCL_E_BLUETOOTH_BASE + 0x000F;
    public const Int32 WCL_E_BLUETOOTH_RADIO_UNAVAILABLE = WCL_E_BLUETOOTH_BASE + 0x0010;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CHANGE_CONNECTABLE_STATE = WCL_E_BLUETOOTH_BASE + 0x0011;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CHANGE_DISCOVERABLE_STATE = WCL_E_BLUETOOTH_BASE + 0x0012;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CHANGE_NAME = WCL_E_BLUETOOTH_BASE + 0x0013;
    public const Int32 WCL_E_BLUETOOTH_FEATURE_NOT_SUPPORTED = WCL_E_BLUETOOTH_BASE + 0x0014;
    public const Int32 WCL_E_BLUETOOTH_UNEXPECTED = WCL_E_BLUETOOTH_BASE + 0x0015;
    public const Int32 WCL_E_BLUETOOTH_LINK_UNEXPECTED = WCL_E_BLUETOOTH_BASE + 0x0016;
    public const Int32 WCL_E_BLUETOOTH_OPERATION_FAILED = WCL_E_BLUETOOTH_BASE + 0x0017;
    public const Int32 WCL_E_BLUETOOTH_OPERATION_CONFLICT = WCL_E_BLUETOOTH_BASE + 0x0018;
    public const Int32 WCL_E_BLUETOOTH_NO_MORE_CONNECTION_ALLOWED = WCL_E_BLUETOOTH_BASE + 0x0019;
    public const Int32 WCL_E_BLUETOOTH_OBJECT_EXISTS = WCL_E_BLUETOOTH_BASE + 0x001A;
    public const Int32 WCL_E_BLUETOOTH_OBJECT_IN_USE = WCL_E_BLUETOOTH_BASE + 0x001B;
    public const Int32 WCL_E_BLUETOOTH_DISCOVERING_RUNNING = WCL_E_BLUETOOTH_BASE + 0x001C;
    public const Int32 WCL_E_BLUETOOTH_DISCOVERING_NOT_RUNNING = WCL_E_BLUETOOTH_BASE + 0x001D;
    public const Int32 WCL_E_BLUETOOTH_DISCOVERING_TERMINATED = WCL_E_BLUETOOTH_BASE + 0x001E;
    public const Int32 WCL_E_BLUETOOTH_CANCELLED_BY_USER = WCL_E_BLUETOOTH_BASE + 0x001F;
    public const Int32 WCL_E_BLUETOOTH_TIMEOUT = WCL_E_BLUETOOTH_BASE + 0x0020;
    public const Int32 WCL_E_BLUETOOTH_CONNECTION_TERMINATED_BY_USER = WCL_E_BLUETOOTH_BASE + 0x0021;
    public const Int32 WCL_E_BLUETOOTH_PENDING = WCL_E_BLUETOOTH_BASE + 0x0022;
    public const Int32 WCL_E_BLUETOOTH_CONNECTION_FAILED = WCL_E_BLUETOOTH_BASE + 0x0023;
    public const Int32 WCL_E_BLUETOOTH_DEVICE_NOT_FOUND = WCL_E_BLUETOOTH_BASE + 0x0024;
    public const Int32 WCL_E_BLUETOOTH_PAIRING = WCL_E_BLUETOOTH_BASE + 0x0025;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_PAIRING = WCL_E_BLUETOOTH_BASE + 0x0026;
    public const Int32 WCL_E_BLUETOOTH_ALREADY_PAIRED = WCL_E_BLUETOOTH_BASE + 0x0027;
    public const Int32 WCL_E_BLUETOOTH_DEVICE_NOT_PAIRED = WCL_E_BLUETOOTH_BASE + 0x0028;
    public const Int32 WCL_E_BLUETOOTH_ACCESS_DENIED = WCL_E_BLUETOOTH_BASE + 0x0029;
    public const Int32 WCL_E_BLUETOOTH_AUTHENTICATION_FAILED = WCL_E_BLUETOOTH_BASE + 0x002A;
    public const Int32 WCL_E_BLUETOOTH_REJECTED = WCL_E_BLUETOOTH_BASE + 0x002B;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_GET_READ_BUFFER = WCL_E_BLUETOOTH_BASE + 0x002C;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_GET_WRITE_BUFFER = WCL_E_BLUETOOTH_BASE + 0x002D;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_READ_BUFFER = WCL_E_BLUETOOTH_BASE + 0x002E;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_WRITE_BUFFER = WCL_E_BLUETOOTH_BASE + 0x002F;
    public const Int32 WCL_E_BLUETOOTH_CLIENT_CONNECTED = WCL_E_BLUETOOTH_BASE + 0x0030;
    public const Int32 WCL_E_BLUETOOTH_CLIENT_NOT_CONNECTED = WCL_E_BLUETOOTH_BASE + 0x0031;
    public const Int32 WCL_E_BLUETOOTH_L2CAP_DISCONNECTED = WCL_E_BLUETOOTH_BASE + 0x0032;
    public const Int32 WCL_E_BLUETOOTH_INVALID_DEVICE_TYPE = WCL_E_BLUETOOTH_BASE + 0x0033;
    public const Int32 WCL_E_BLUETOOTH_CHANNEL_IN_USE = WCL_E_BLUETOOTH_BASE + 0x0034;
    public const Int32 WCL_E_BLUETOOTH_SERVICE_NOT_VALID = WCL_E_BLUETOOTH_BASE + 0x0035;
    public const Int32 WCL_E_BLUETOOTH_SERVICE_NOT_FOUND = WCL_E_BLUETOOTH_BASE + 0x0036;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_SOCKET = WCL_E_BLUETOOTH_BASE + 0x0037;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_CLIENT_SECURITY = WCL_E_BLUETOOTH_BASE + 0x0038;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_EVENT = WCL_E_BLUETOOTH_BASE + 0x0039;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_EVENT = WCL_E_BLUETOOTH_BASE + 0x003A;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_LOCK_CONNECT_MUTEX = WCL_E_BLUETOOTH_BASE + 0x003B;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_INIT_OVERLAPPED_OPERATION = WCL_E_BLUETOOTH_BASE + 0x003C;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_DISCONNECT_EVENT = WCL_E_BLUETOOTH_BASE + 0x003D;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_CONNECT_EVENT = WCL_E_BLUETOOTH_BASE + 0x003E;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_LOCK_SDP_MUTEX = WCL_E_BLUETOOTH_BASE + 0x003F;
    public const Int32 WCL_E_BLUETOOTH_RFCOMM_SESSION_DISCONNECTED = WCL_E_BLUETOOTH_BASE + 0x0040;
    public const Int32 WCL_E_BLUETOOTH_RFCOMM_DOWN = WCL_E_BLUETOOTH_BASE + 0x0041;
    public const Int32 WCL_E_BLUETOOTH_RFCOMM_DISCONNECTED = WCL_E_BLUETOOTH_BASE + 0x0042;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_TO_RESOLVE_ADDRESS = WCL_E_BLUETOOTH_BASE + 0x0043;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_ADD_ADP_RECORD = WCL_E_BLUETOOTH_BASE + 0x0044;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_SERVER_SECURITY = WCL_E_BLUETOOTH_BASE + 0x0045;
    public const Int32 WCL_E_BLUETOOTH_LOCAL_SERVICE_ACTIVE = WCL_E_BLUETOOTH_BASE + 0x0046;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_SERVER = WCL_E_BLUETOOTH_BASE + 0x0047;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_ENUMERATE_LOCAL_SERVICES = WCL_E_BLUETOOTH_BASE + 0x0048;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_STOP_LOCAL_SERVER = WCL_E_BLUETOOTH_BASE + 0x0049;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_TO_UPDATE_LOCAL_SERVER = WCL_E_BLUETOOTH_BASE + 0x004A;
    public const Int32 WCL_E_BLUETOOTH_SETUP_COM_FAILED = WCL_E_BLUETOOTH_BASE + 0x004B;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_OPEN_CLIENT_COM = WCL_E_BLUETOOTH_BASE + 0x004C;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_OPEN_SERVER_COM = WCL_E_BLUETOOTH_BASE + 0x004D;
    public const Int32 WCL_E_BLUETOOTH_WRITE_FAILED = WCL_E_BLUETOOTH_BASE + 0x004E;
    public const Int32 WCL_E_BLUETOOTH_READ_FAILED = WCL_E_BLUETOOTH_BASE + 0x004F;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_WND = WCL_E_BLUETOOTH_BASE + 0x0050;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_REGISTER_MESSAGE = WCL_E_BLUETOOTH_BASE + 0x0051;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_SYNC_EVENT = WCL_E_BLUETOOTH_BASE + 0x0052;
    public const Int32 WCL_E_BLUETOOTH_SDP_TRANSACTION = WCL_E_BLUETOOTH_BASE + 0x0053;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_SDP_THREAD = WCL_E_BLUETOOTH_BASE + 0x0054;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_CONNECT_THREAD = WCL_E_BLUETOOTH_BASE + 0x0055;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_LISTEN_THREAD = WCL_E_BLUETOOTH_BASE + 0x0056;
    public const Int32 WCL_E_BLUETOOTH_DISCOVERING_FAILED = WCL_E_BLUETOOTH_BASE + 0x0057;
    public const Int32 WCL_E_BLUETOOTH_READ_REMOTE_NAME_FAILED = WCL_E_BLUETOOTH_BASE + 0x0058;
    public const Int32 WCL_E_BLUETOOTH_DESTROY_COM_FAILED = WCL_E_BLUETOOTH_BASE + 0x0059;
    public const Int32 WCL_E_BLUETOOTH_CONNECT_COM_FAILED = WCL_E_BLUETOOTH_BASE + 0x005A;
    public const Int32 WCL_E_BLUETOOTH_DISCONNECT_COM_FAILED = WCL_E_BLUETOOTH_BASE + 0x005B;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_TO_SWITCH_ON_OR_OFF = WCL_E_BLUETOOTH_BASE + 0x005C;
    public const Int32 WCL_E_BLUETOOTH_CANNOT_ASSIGN_PSM = WCL_E_BLUETOOTH_BASE + 0x005D;
    public const Int32 WCL_E_BLUETOOTH_GETLOCALINFO_FAILED = WCL_E_BLUETOOTH_BASE + 0x005E;
    public const Int32 WCL_E_BLUETOOTH_DISCONNECT_SDP_FAILED = WCL_E_BLUETOOTH_BASE + 0x005F;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_REGISTER_COM_NOTIFICATION = WCL_E_BLUETOOTH_BASE + 0x0060;
    public const Int32 WCL_E_BLUETOOTH_SETLOCALINFO_FAILED = WCL_E_BLUETOOTH_BASE + 0x0061;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_TO_GET_CONNECTED_DEVICES = WCL_E_BLUETOOTH_BASE + 0x0062;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CONNECT = WCL_E_BLUETOOTH_BASE + 0x0063;
    public const Int32 WCL_E_BLUETOOTH_CONNECT_PSM = WCL_E_BLUETOOTH_BASE + 0x0064;
    public const Int32 WCL_E_BLUETOOTH_SDP_PARSE_ERROR = WCL_E_BLUETOOTH_BASE + 0x0065;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_READ_RSSI = WCL_E_BLUETOOTH_BASE + 0x0066;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CHANGE_PAIRING_MODE = WCL_E_BLUETOOTH_BASE + 0x0067;
    public const Int32 WCL_E_BLUETOOTH_SDP_ERROR = WCL_E_BLUETOOTH_BASE + 0x0068;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_THREAD = WCL_E_BLUETOOTH_BASE + 0x0069;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_INIT_EVENT = WCL_E_BLUETOOTH_BASE + 0x006A;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_INIT_THREAD = WCL_E_BLUETOOTH_BASE + 0x006B;
    public const Int32 WCL_E_BLUETOOTH_VCOM_NOT_FOUND = WCL_E_BLUETOOTH_BASE + 0x006C;
    public const Int32 WCL_E_BLUETOOTH_VCOM_EXISTS = WCL_E_BLUETOOTH_BASE + 0x006D;
    public const Int32 WCL_E_BLUETOOTH_CREATE_DEVICE_STATICS_FAILED = WCL_E_BLUETOOTH_BASE + 0x006E;
    public const Int32 WCL_E_BLUETOOTH_START_ASYNC_OPERATION_FAILED = WCL_E_BLUETOOTH_BASE + 0x006F;
    public const Int32 WCL_E_BLUETOOTH_SET_ASYNC_OPERATION_EVENT_HANDLER_FAILED = WCL_E_BLUETOOTH_BASE + 0x0070;
    public const Int32 WCL_E_BLUETOOTH_CREATE_DEVICE_FAILED = WCL_E_BLUETOOTH_BASE + 0x0071;
    public const Int32 WCL_E_BLUETOOTH_GET_ASYNC_OPERATION_RESULT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0072;
    public const Int32 WCL_E_BLUETOOTH_GET_DEVICE_ID_FAILED = WCL_E_BLUETOOTH_BASE + 0x0073;
    public const Int32 WCL_E_BLUETOOTH_GET_DEVICE_PROPERTIES_FAILED = WCL_E_BLUETOOTH_BASE + 0x0074;
    public const Int32 WCL_E_BLUETOOTH_START_RSSI_THREAD_FAILED = WCL_E_BLUETOOTH_BASE + 0x0075;
    public const Int32 WCL_E_BLUETOOTH_GET_RSSI_READING_RESULT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0076;
    public const Int32 WCL_E_BLUETOOTH_INCOMPATIBLE_OS_BITS = WCL_E_BLUETOOTH_BASE + 0x0077;
    public const Int32 WCL_E_BLUETOOTH_GET_RADIOS_LIST_FAILED = WCL_E_BLUETOOTH_BASE + 0x0078;
    public const Int32 WCL_E_BLUETOOTH_GET_RADIOS_COUNT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0079;
    public const Int32 WCL_E_BLUETOOTH_GET_BLUETOOTH_RADIO_FAILED = WCL_E_BLUETOOTH_BASE + 0x007A;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CHANGE_RADIO_STATE = WCL_E_BLUETOOTH_BASE + 0x007B;
    public const Int32 WCL_E_BLUETOOTH_START_GET_DEV_TYPE_THREAD_FAILED = WCL_E_BLUETOOTH_BASE + 0x007C;
    public const Int32 WCL_E_BLUETOOTH_GET_DEV_TYPE_THREAD_GET_RESULT_FAILED = WCL_E_BLUETOOTH_BASE + 0x007D;
    public const Int32 WCL_E_BLUETOOTH_START_GET_DEV_NAME_THREAD_FAILED = WCL_E_BLUETOOTH_BASE + 0x007E;
    public const Int32 WCL_E_BLUETOOTH_GET_DEV_NAME_THREAD_GET_RESULT_FAILED = WCL_E_BLUETOOTH_BASE + 0x007F;
    public const Int32 WCL_E_BLUETOOTH_NO_SYSTEM_RESOURCES = WCL_E_BLUETOOTH_BASE + 0x0080;
    public const Int32 WCL_E_BLUETOOTH_CREATE_REG_CHANGE_TERMINATION_EVENT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0081;
    public const Int32 WCL_E_BLUETOOTH_CREATE_REG_CHANGE_RESULT_EVENT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0082;
    public const Int32 WCL_E_BLUETOOTH_START_REG_CHANGE_THREAD_FAILED = WCL_E_BLUETOOTH_BASE + 0x0083;
    public const Int32 WCL_E_BLUETOOTH_REGISTER_AUTHENTICATION_CALLBACK_FAILED = WCL_E_BLUETOOTH_BASE + 0x0084;
    public const Int32 WCL_E_BLUETOOTH_FAILED_TO_OPEN_AUTH_AGENT_REG_KEY = WCL_E_BLUETOOTH_BASE + 0x0085;
    public const Int32 WCL_E_BLUETOOTH_CREATE_REG_CHANGES_NOTIFICATION_EVENT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0086;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_REGISTRY_CHANGES_NOTIFICATIONS = WCL_E_BLUETOOTH_BASE + 0x0087;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_TO_DISABLE_AUTHENTICATION_AGENT = WCL_E_BLUETOOTH_BASE + 0x0088;
    public const Int32 WCL_E_BLUETOOTH_PAIRED_BY_OTHER = WCL_E_BLUETOOTH_BASE + 0x0089;
    public const Int32 WCL_E_BLUETOOTH_DEVICE_ALREADY_INSTALLED = WCL_E_BLUETOOTH_BASE + 0x008A;
    public const Int32 WCL_E_BLUETOOTH_DEVICE_NOT_INSTALLED = WCL_E_BLUETOOTH_BASE + 0x008B;
    public const Int32 WCL_E_BLUETOOTH_DEVICE_NOT_CONNECTED = WCL_E_BLUETOOTH_BASE + 0x008C;
    public const Int32 WCL_E_BLUETOOTH_ENUM_CONNECTION_FAILED = WCL_E_BLUETOOTH_BASE + 0x008D;
    public const Int32 WCL_E_BLUETOOTH_WAIT_FAILED = WCL_E_BLUETOOTH_BASE + 0x008E;

    public const Int32 WCL_E_BLUETOOTH_LE_BASE = WCL_E_BLUETOOTH_BASE + 0x1000;
    public const Int32 WCL_E_BLUETOOTH_LE_INVALID_HANDLE = WCL_E_BLUETOOTH_LE_BASE + 0x0000;
    public const Int32 WCL_E_BLUETOOTH_LE_READ_NOT_PERMITTED = WCL_E_BLUETOOTH_LE_BASE + 0x0001;
    public const Int32 WCL_E_BLUETOOTH_LE_WRITE_NOT_PERMITTED = WCL_E_BLUETOOTH_LE_BASE + 0x0002;
    public const Int32 WCL_E_BLUETOOTH_LE_INVALID_PDU = WCL_E_BLUETOOTH_LE_BASE + 0x0003;
    public const Int32 WCL_E_BLUETOOTH_LE_INSUFFICIENT_AUTHENTICATION = WCL_E_BLUETOOTH_LE_BASE + 0x0004;
    public const Int32 WCL_E_BLUETOOTH_LE_REQUEST_NOT_SUPPORTED = WCL_E_BLUETOOTH_LE_BASE + 0x0005;
    public const Int32 WCL_E_BLUETOOTH_LE_INVALID_OFFSET = WCL_E_BLUETOOTH_LE_BASE + 0x0006;
    public const Int32 WCL_E_BLUETOOTH_LE_INSUFFICIENT_AUTHORIZATION = WCL_E_BLUETOOTH_LE_BASE + 0x0007;
    public const Int32 WCL_E_BLUETOOTH_LE_PREPARE_QUEUE_FULL = WCL_E_BLUETOOTH_LE_BASE + 0x0008;
    public const Int32 WCL_E_BLUETOOTH_LE_ATTRIBUTE_NOT_FOUND = WCL_E_BLUETOOTH_LE_BASE + 0x0009;
    public const Int32 WCL_E_BLUETOOTH_LE_ATTRIBUTE_NOT_LONG = WCL_E_BLUETOOTH_LE_BASE + 0x000A;
    public const Int32 WCL_E_BLUETOOTH_LE_INSUFFICIENT_ENCRYPTION_KEYSIZE = WCL_E_BLUETOOTH_LE_BASE + 0x000B;
    public const Int32 WCL_E_BLUETOOTH_LE_INVALID_ATTRIBUTE_VALUE_LENGTH = WCL_E_BLUETOOTH_LE_BASE + 0x000C;
    public const Int32 WCL_E_BLUETOOTH_LE_INSUFFICIENT_ENCRYPTION = WCL_E_BLUETOOTH_LE_BASE + 0x000D;
    public const Int32 WCL_E_BLUETOOTH_LE_UNSUPPORTED_GROUP_TYPE = WCL_E_BLUETOOTH_LE_BASE + 0x000E;
    public const Int32 WCL_E_BLUETOOTH_LE_INSUFFICIENT_RESOURCES = WCL_E_BLUETOOTH_LE_BASE + 0x000F;
    public const Int32 WCL_E_BLUETOOTH_LE_SMP_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0010;
    public const Int32 WCL_E_BLUETOOTH_LE_TASK_CANCEL = WCL_E_BLUETOOTH_LE_BASE + 0x0011;
    public const Int32 WCL_E_BLUETOOTH_LE_CONNECT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0012;
    public const Int32 WCL_E_BLUETOOTH_LE_TIMEOUT = WCL_E_BLUETOOTH_LE_BASE + 0x0013;
    public const Int32 WCL_E_BLUETOOTH_LE_WRONG_CONFIGURATION = WCL_E_BLUETOOTH_LE_BASE + 0x0014;
    public const Int32 WCL_E_BLUETOOTH_LE_PROCEDURE_IN_PROGRESS = WCL_E_BLUETOOTH_LE_BASE + 0x0015;
    public const Int32 WCL_E_BLUETOOTH_LE_OUT_OF_RANGE = WCL_E_BLUETOOTH_LE_BASE + 0x0016;
    public const Int32 WCL_E_BLUETOOTH_LE_RELIABLE_WRITE_ACTIVE = WCL_E_BLUETOOTH_LE_BASE + 0x0017;
    public const Int32 WCL_E_BLUETOOTH_LE_RELIABLE_WRITE_NOT_ACTIVE = WCL_E_BLUETOOTH_LE_BASE + 0x0018;
    public const Int32 WCL_E_BLUETOOTH_LE_ALREADY_SUBSCRIBED = WCL_E_BLUETOOTH_LE_BASE + 0x0019;
    public const Int32 WCL_E_BLUETOOTH_LE_NOT_SUBSCRIBED = WCL_E_BLUETOOTH_LE_BASE + 0x001A;
    public const Int32 WCL_E_BLUETOOTH_LE_DEVICES_SCANNING_ENABLED = WCL_E_BLUETOOTH_LE_BASE + 0x001B;
    public const Int32 WCL_E_BLUETOOTH_LE_DEVICES_SCANNING_DISABLED = WCL_E_BLUETOOTH_LE_BASE + 0x001C;
    public const Int32 WCL_E_BLUETOOTH_LE_INAVLID_USER_BUFFER = WCL_E_BLUETOOTH_LE_BASE + 0x001D;
    public const Int32 WCL_E_BLUETOOTH_LE_INCONSISTENT_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x001E;
    public const Int32 WCL_E_BLUETOOTH_LE_COMMUNICATION_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x001F;
    public const Int32 WCL_E_BLUETOOTH_LE_CHARACTERISTIC_NOT_READABLE = WCL_E_BLUETOOTH_LE_BASE + 0x0020;
    public const Int32 WCL_E_BLUETOOTH_LE_CREATE_WATCHER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0021;
    public const Int32 WCL_E_BLUETOOTH_LE_SET_SCANNING_MODE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0022;
    public const Int32 WCL_E_BLUETOOTH_LE_START_WATCHER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0023;
    public const Int32 WCL_E_BLUETOOTH_LE_START_WINRT_THREAD_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0024;
    public const Int32 WCL_E_BLUETOOTH_LE_SET_EVENT_HANDLER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0025;
    public const Int32 WCL_E_BLUETOOTH_LE_CREATE_DEVICE_STATICS_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0026;
    public const Int32 WCL_E_BLUETOOTH_LE_CREATE_DEVICE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0027;
    public const Int32 WCL_E_BLUETOOTH_LE_START_ASYNC_OPERATION_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0028;
    public const Int32 WCL_E_BLUETOOTH_LE_SET_ASYNC_OPERATION_EVENT_HANDLER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0029;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_ASYNC_OPERATION_RESULT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002A;
    public const Int32 WCL_E_BLUETOOTH_LE_CREATE_DEVICE2_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002B;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_INFORMATION_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002C;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_INFORMATION2_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002D;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_INFORMATION_PAIRING_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002E;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_INFORMATION_PAIRING2_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002F;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_INFORMATION_CUSTOM_PAIRING_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0030;
    public const Int32 WCL_E_BLUETOOTH_LE_BEACON_MONITORING_RUNNING = WCL_E_BLUETOOTH_LE_BASE + 0x0031;
    public const Int32 WCL_E_BLUETOOTH_LE_BEACON_MONITORING_NOT_RUNNING = WCL_E_BLUETOOTH_LE_BASE + 0x0032;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_RUNNING = WCL_E_BLUETOOTH_LE_BASE + 0x0033;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_NOT_RUNNING = WCL_E_BLUETOOTH_LE_BASE + 0x0034;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_UNBALE_CREATE_INIT_EVENT = WCL_E_BLUETOOTH_LE_BASE + 0x0035;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_UNBALE_CREATE_TERMINATE_EVENT = WCL_E_BLUETOOTH_LE_BASE + 0x0036;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_UNBALE_START_THREAD = WCL_E_BLUETOOTH_LE_BASE + 0x0037;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_START_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0038;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_GET_ADVERTISER = WCL_E_BLUETOOTH_LE_BASE + 0x0039;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_GET_ADVERTISER_MANUFACTURER_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x003A;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_SET_ADVERTISING_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x003B;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_ADD_ADVERTISING_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x003C;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_GET_ADVERTISER_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x003D;
    public const Int32 WCL_E_BLUETOOTH_LE_EDDYSTONE_URL_TOO_SHORT = WCL_E_BLUETOOTH_LE_BASE + 0x003E;
    public const Int32 WCL_E_BLUETOOTH_LE_EDDYSTONE_URL_SCHEME_INVALID = WCL_E_BLUETOOTH_LE_BASE + 0x003F;
    public const Int32 WCL_E_BLUETOOTH_LE_EDDYSTONE_URL_TOO_LONG = WCL_E_BLUETOOTH_LE_BASE + 0x0040;
    public const Int32 WCL_E_BLUETOOTH_LE_ASYNC_PAIR_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0041;
    public const Int32 WCL_E_BLUETOOTH_LE_ASYNC_PAIR_ERROR = WCL_E_BLUETOOTH_LE_BASE + 0x0042;
    public const Int32 WCL_E_BLUETOOTH_LE_MANUAL_PAIRING_REQUIRED = WCL_E_BLUETOOTH_LE_BASE + 0x0043;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_NOT_READY_TO_PAIR = WCL_E_BLUETOOTH_LE_BASE + 0x0044;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_NOT_PAIRED = WCL_E_BLUETOOTH_LE_BASE + 0x0045;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_CONNECTION_REJECTED = WCL_E_BLUETOOTH_LE_BASE + 0x0046;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_TOO_MANY_CONNECTIONS = WCL_E_BLUETOOTH_LE_BASE + 0x0047;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_HARDWARE_FAILURE = WCL_E_BLUETOOTH_LE_BASE + 0x0048;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_TIMEOUT = WCL_E_BLUETOOTH_LE_BASE + 0x0049;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_NOT_ALLOWED = WCL_E_BLUETOOTH_LE_BASE + 0x004A;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_FAILURE = WCL_E_BLUETOOTH_LE_BASE + 0x004B;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_NO_SUPPORTED_PROFILE = WCL_E_BLUETOOTH_LE_BASE + 0x004C;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_PROTECTION_LEVEL_COULD_NOT_BE_MET = WCL_E_BLUETOOTH_LE_BASE + 0x004D;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_ACCESS_DENIED = WCL_E_BLUETOOTH_LE_BASE + 0x004E;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_INVALID_CEREMONY_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x004F;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_PAIRING_CANCELED = WCL_E_BLUETOOTH_LE_BASE + 0x0050;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_OPERATION_ALREADY_IN_POROGRESS = WCL_E_BLUETOOTH_LE_BASE + 0x0051;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_REQUIRED_HANDLER_NOT_REGISTERED = WCL_E_BLUETOOTH_LE_BASE + 0x0052;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_REJECTED_BY_HANDLER = WCL_E_BLUETOOTH_LE_BASE + 0x0053;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_REMOTE_DEVICE_HAS_ASSOCIATION = WCL_E_BLUETOOTH_LE_BASE + 0x0054;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0055;
    public const Int32 WCL_E_BLUETOOTH_LE_SET_PROTECTION_LEVEL_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0056;
    public const Int32 WCL_E_BLUETOOTH_LE_CHARACTERISTIC_NOT_WRITABLE = WCL_E_BLUETOOTH_LE_BASE + 0x0057;
    public const Int32 WCL_E_BLUETOOTH_LE_DEVICE_NOT_DISCOVERED = WCL_E_BLUETOOTH_LE_BASE + 0x0058;
    public const Int32 WCL_E_BLUETOOTH_LE_ALREADY_PAIRED = WCL_E_BLUETOOTH_LE_BASE + 0x0059;
    public const Int32 WCL_E_BLUETOOTH_LE_UNSUPPORTED_BY_HARDWARE = WCL_E_BLUETOOTH_LE_BASE + 0x005A;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_START_UNPAIRING = WCL_E_BLUETOOTH_LE_BASE + 0x005B;
    public const Int32 WCL_E_BLUETOOTH_LE_DEVICE_NOT_FOUND = WCL_E_BLUETOOTH_LE_BASE + 0x005C;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_ID_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x005D;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_PROPERTIES_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x005E;
    public const Int32 WCL_E_BLUETOOTH_LE_FEATURE_NOT_SUPPORTED = WCL_E_BLUETOOTH_LE_BASE + 0x005F;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_READ_RSSI = WCL_E_BLUETOOTH_LE_BASE + 0x0060;
    public const Int32 WCL_E_BLUETOOTH_LE_START_RSSI_THREAD_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0061;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_RSSI_READING_RESULT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0062;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_SET_NAME_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0063;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_OPERATION_RESULT_FAULED = WCL_E_BLUETOOTH_LE_BASE + 0x0064;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_ROOT_SERVICE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0065;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_SERVICE_HANDLE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0066;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISTIC_HANDLE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0067;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_HANDLE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0068;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_UUID_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0069;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMATS_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006A;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMATS_LIST_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006B;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006C;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_TYPE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006D;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_EXPONENT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006E;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_UNIT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006F;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_NAMESPACE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0070;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_DESCRIPTION_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0071;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_VALUE_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0072;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_VALUE_RAW_DATA_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0073;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_VALUE_DATA_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0074;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISTIC_UUID_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0075;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISTIC_PROPETIES_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0076;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_VALUE_DATA_BUFFER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0077;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISTIC_VALUE_DATA_BUFFER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0078;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISTIC_VALUE_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0079;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISITC_VALUE_RAW_DATA_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007A;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISITC_VALUE_DATA_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007B;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTORS_LIST_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007C;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_SERVICE_UUID_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007D;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISITCS_LIST_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007E;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_SERVICES_LIST_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007F;
};

// The base class for Bluetooth Framework C++ Edition wrappers.
// It must be disposable.
public abstract class BluetoothImports : IDisposable
{
    private Boolean FDisposed;

    private void Dispose(Boolean Disposing)
    {
        if (FDisposed)
            return;

        Free();

        FDisposed = true;
    }

    // This can be overridden. Called when object is disposing.
    protected virtual void Free()
    {

    }

    protected Boolean Disposed { get { return FDisposed; } }

    protected internal const string WclGattClientDllName = "WclGattClientDll.dll";

    public BluetoothImports()
    {
        FDisposed = false;
    }

    ~BluetoothImports()
    {
        Dispose(false);
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
};

#region Bluetooth Manager delegates
public delegate void DeviceFoundEvent(System.Object sender, IntPtr Radio, Int64 Address);
public delegate void DiscoveringStartedEvent(System.Object sender, IntPtr Radio);
public delegate void DiscoveringCompletedEvent(System.Object sender, IntPtr Radio, Int32 Error);
#endregion

public enum WinVer
{
    verUnknown = 1,
    verWinXP = 2,
    verWinVista = 3,
    verWin7 = 4,
    verWin8 = 5,
    verWin81 = 6,
    verWin10 = 7
};

public class BluetoothManager : BluetoothImports
{
    #region Bluetooth Manager callback types
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void NOTIFY_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void DEVICE_FOUND_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void DISCOVERING_STARTED_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void DISCOVERING_COMPLETED_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I4), In] Int32 Error);
    #endregion

    #region Bluetooth Manager imports
    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.SysInt)]
    private static extern IntPtr ManagerCreate();

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerDestroy(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ManagerOpen(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ManagerClose(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ManagerGetRadioCount(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.SysInt)]
    private static extern IntPtr ManagerGetRadio(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.I4)] Int32 Index);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetAfterOpen(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] NOTIFY_EVENT Event);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetBeforeClose(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] NOTIFY_EVENT Event);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetOnDeviceFound(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] DEVICE_FOUND_EVENT Event);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetOnDiscoveringStarted(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] DISCOVERING_STARTED_EVENT Event);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetOnDiscoveringCompleted(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] DISCOVERING_COMPLETED_EVENT Event);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioDiscover(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.U4), In] UInt32 Timeout);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioTerminate(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern Boolean RadioIsAvailable(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioGetDeviceName(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Name,
        [param: MarshalAs(UnmanagedType.I4), In] Int32 Len);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioRemoteUnpair(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioIsConnectable(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.Bool), Out] out Boolean Connectable);
    #endregion

    // Bluetooth Manager instance.
    private IntPtr FManager;

    #region Bluetooth Manager callback delegates
    private NOTIFY_EVENT FAfterOpen;
    private NOTIFY_EVENT FBeforeClose;
    private DEVICE_FOUND_EVENT FOnDeviceFound;
    private DISCOVERING_STARTED_EVENT FOnDiscoveringStarted;
    private DISCOVERING_COMPLETED_EVENT FOnDiscoveringCompleted;
    #endregion

    #region Bluetooth Manager callback handlers
    private void DoAfterOpen(IntPtr sender)
    {
        if (AfterOpen != null)
            AfterOpen(this, EventArgs.Empty);
    }

    private void DoBeofreClose(IntPtr sender)
    {
        if (BeforeClose != null)
            BeforeClose(this, EventArgs.Empty);
    }

    private void DoDeviceFound(IntPtr sender, IntPtr Radio, Int64 Address)
    {
        if (OnDeviceFound != null)
            OnDeviceFound(this, Radio, Address);
    }

    private void DoDiscoveringStarted(IntPtr sender, IntPtr Radio)
    {
        if (OnDiscoveringStarted != null)
            OnDiscoveringStarted(this, Radio);
    }

    private void DoDiscoveringCompleted(IntPtr sender, IntPtr Radio, Int32 Error)
    {
        if (OnDiscoveringCompleted != null)
            OnDiscoveringCompleted(this, Radio, Error);
    }
    #endregion

    protected override void Free()
    {
        // Call close first if we did not do it yet.
        Close();

        // Cleanup callbacks.
        ManagerSetAfterOpen(FManager, null);
        ManagerSetBeforeClose(FManager, null);
        ManagerSetOnDeviceFound(FManager, null);
        ManagerSetOnDiscoveringCompleted(FManager, null);
        ManagerSetOnDiscoveringStarted(FManager, null);
        
        // Dispose delegates.
        FAfterOpen = null;
        FBeforeClose = null;
        FOnDeviceFound = null;
        FOnDiscoveringStarted = null;
        FOnDiscoveringCompleted = null;
        
        // Delete Bluetooth Manager instance.
        ManagerDestroy(FManager);

        // And that's all
        FManager = IntPtr.Zero;
    }

    public BluetoothManager()
        : base()
    {
        AfterOpen = null;
        BeforeClose = null;
        OnDeviceFound = null;
        OnDiscoveringStarted = null;
        OnDiscoveringCompleted = null;
        
        // Initialize callback delegates with its handlers.
        FAfterOpen = new NOTIFY_EVENT(DoAfterOpen);
        FBeforeClose = new NOTIFY_EVENT(DoBeofreClose);
        FOnDeviceFound = new DEVICE_FOUND_EVENT(DoDeviceFound);
        FOnDiscoveringCompleted = new DISCOVERING_COMPLETED_EVENT(DoDiscoveringCompleted);
        FOnDiscoveringStarted = new DISCOVERING_STARTED_EVENT(DoDiscoveringStarted);
        
        // Create Bluetooth Manager instance...
        FManager = ManagerCreate();
        // ...and setup callbacks.
        ManagerSetAfterOpen(FManager, FAfterOpen);
        ManagerSetBeforeClose(FManager, FBeforeClose);
        ManagerSetOnDeviceFound(FManager, FOnDeviceFound);
        ManagerSetOnDiscoveringCompleted(FManager, FOnDiscoveringCompleted);
        ManagerSetOnDiscoveringStarted(FManager, FOnDiscoveringStarted);
    }

    #region Bluetooth Manager methods
    public Int32 Open()
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return ManagerOpen(FManager);
    }

    public Int32 Close()
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return ManagerClose(FManager);
    }

    public Int32 Discover(IntPtr Radio, UInt32 Timeout)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioDiscover(Radio, Timeout);
    }

    public Int32 Terminate(IntPtr Radio)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioTerminate(Radio);
    }

    public Boolean IsRadioAvailable(IntPtr Radio)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioIsAvailable(Radio);
    }

    public Int32 GetRemoteName(IntPtr Radio, Int64 Address, out String Name)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        Name = "";

        // Bluetooth device's name can not be longer that 128 chars. To be 100% sure we will use 256 chars
        // memory block.
        IntPtr pName;
        Int32 Result;

        pName = Marshal.AllocHGlobal(256 * sizeof(Char));
        try
        {
            Result = RadioGetDeviceName(Radio, Address, pName, 256);
            if (Result == BluetoothErrors.WCL_E_SUCCESS)
                Name = Marshal.PtrToStringUni(pName);
        }
        finally
        {
            Marshal.FreeHGlobal(pName);
        }

        return Result;
    }

    public Int32 RemoteUnpair(IntPtr Radio, Int64 Address)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioRemoteUnpair(Radio, Address);
    }

    public Int32 GetConnectable(IntPtr Radio, out Boolean Connectable)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioIsConnectable(Radio, out Connectable);
    }
    #endregion

    #region Bluetooth Manager properties
    public Int32 Count
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ManagerGetRadioCount(FManager);
        }
    }

    public IntPtr this[Int32 Index]
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ManagerGetRadio(FManager, Index);
        }
    }
    #endregion

    #region Bluetooth Manager events
    public event EventHandler AfterOpen;
    public event EventHandler BeforeClose;
    public event DeviceFoundEvent OnDeviceFound;
    public event DiscoveringStartedEvent OnDiscoveringStarted;
    public event DiscoveringCompletedEvent OnDiscoveringCompleted;
    #endregion
};

#region GATT data types.
[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct GattUuid
{
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsShortUuid;
    [MarshalAs(UnmanagedType.U2)]
    public UInt16 ShortUuid;
    public Guid LongUuid;
};

[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct GattService
{
    public GattUuid Uuid;
    [MarshalAs(UnmanagedType.U2)]
    public UInt16 Handle;
};

[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct GattServices
{
    [MarshalAs(UnmanagedType.U1)]
    public Byte Count;
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 255)]
    public GattService[] Services;
};

[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct GattCharacteristic
{
    [MarshalAs(UnmanagedType.U2)]
    public UInt16 ServiceHandle;
    public GattUuid Uuid;
    [MarshalAs(UnmanagedType.U2)]
    public UInt16 Handle;
    [MarshalAs(UnmanagedType.U2)]
    public UInt16 ValueHandle;
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsBroadcastable;
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsReadable;
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsWritable;
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsWritableWithoutResponse;
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsSignedWritable;
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsNotifiable;
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsIndicatable;
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean HasExtendedProperties;
};

[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct GattCharacteristics
{
    [MarshalAs(UnmanagedType.U1)]
    public Byte Count;
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 255)]
    public GattCharacteristic[] Chars;
};

[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct GattDescriptor
{
    [MarshalAs(UnmanagedType.U2)]
    public UInt16 ServiceHandle;
    [MarshalAs(UnmanagedType.U2)]
    public UInt16 CharacteristicHandle;
    public GattDescriptorType DescriptorType;
    public GattUuid Uuid;
    [MarshalAs(UnmanagedType.U2)]
    public UInt16 Handle;
};

public struct GattDescriptors
{
    [MarshalAs(UnmanagedType.U1)]
    public Byte Count;
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 255)]
    public GattDescriptor[] Descs;
};

public struct GattCharacteristicExtendedProperties
{
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsReliableWriteEnabled;
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsAuxiliariesWritable;
};

public struct GattClientCharacteristicConfiguration
{
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsSubscribeToNotification;
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsSubscribeToIndication;
};

public struct GattServerCharacteristicConfiguration
{
    [MarshalAs(UnmanagedType.Bool)]
    public Boolean IsBroadcast;
};

public struct GattCharacteristicFormat
{
    [MarshalAs(UnmanagedType.U1)]
    public Byte Format;
    [MarshalAs(UnmanagedType.U1)]
    public Byte Exponent;
    public GattUuid AUnit;
    [MarshalAs(UnmanagedType.U1)]
    public Byte NameSpace;
    public GattUuid Description;
};

public struct GattDescriptorValue
{
    public GattDescriptorType AType;
    public GattUuid Uuid;
    public GattCharacteristicExtendedProperties CharacteristicExtendedProperties;
    public GattClientCharacteristicConfiguration ClientCharacteristicConfiguration;
    public GattServerCharacteristicConfiguration ServerCharacteristicConfiguration;
    public GattCharacteristicFormat CharacteristicFormat;
};
#endregion

#region GATT Enumerations
public enum ClientState
{
    csDisconnected,
    csPreparing,
    csConnecting,
    csConnected,
    csDisconnecting
};

public enum GattOperationFlag
{
    goNone,
    goReadFromDevice,
    goReadFromCache
};

public enum GattProtectionLevel
{
    plNone,
    plAuthentication,
    plEncryption,
    plEncryptionAndAuthentication
};

public enum GattDescriptorType
{
    dtCharacteristicExtendedProperties,
    dtCharacteristicUserDescription,
    dtClientCharacteristicConfiguration,
    dtServerCharacteristicConfiguration,
    dtCharacteristicFormat,
    dtCharacteristicAggregateFormat,
    dtCustomDescriptor
};
#endregion

#region GATT client delegates
public delegate void ClietConnect(System.Object sender, Int32 Error);
public delegate void ClientDisconnect(System.Object sender, Int32 Reason);
public delegate void ClientChanged(System.Object sender, UInt16 Handle, Byte[] Value);
#endregion

public class GattClient : BluetoothImports
{
    #region GATT client callback types.
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void GATTCLIENT_CONNECT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.I4), In] Int32 Error);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void GATTCLIENT_DISCONNECT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.I4), In] Int32 Reason);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void GATTCLIENT_ONCHANGED(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.U2), In] UInt16 Handle,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Value,
        [param: MarshalAs(UnmanagedType.U4), In] UInt32 ValueLen);
    #endregion

    #region GATT client imports
    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.SysInt)]
    private static extern IntPtr GattClientCreate();

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void GattClientDestroy(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void GattClientSetOnConnect(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] GATTCLIENT_CONNECT Event);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void GattClientSetOnDisconnect(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] GATTCLIENT_DISCONNECT Event);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void GattClientSetOnChanged(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] GATTCLIENT_ONCHANGED Event);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientConnect(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientDisconnect(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientGetServices(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: In, Out] ref GattServices Services);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientGetCharas(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: In] ref GattService Service,
        [param: In, Out] ref GattCharacteristics Chars);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientGetDescriptors(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: In] ref GattCharacteristic Characteristic,
        [param: In, Out] ref GattDescriptors Descriptors);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientSubscribe(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: In] ref GattCharacteristic Char);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientUnsubscribe(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: In] ref GattCharacteristic Char);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientReadCharacteristicValue(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: In] ref GattCharacteristic Char,
        [param: MarshalAs(UnmanagedType.SysInt), In, Out] ref IntPtr ppValue,
        [param: MarshalAs(UnmanagedType.U4), In, Out] ref UInt32 pSize);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientReadDescriptorValue(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: In] ref GattDescriptor Desc,
        [param: In, Out] ref GattDescriptorValue Value);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientWriteCharacteristicValue(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: In] ref GattCharacteristic Char,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr pValue,
        [param: MarshalAs(UnmanagedType.U4), In] UInt32 Size);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientWriteDescriptorValue(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: In] ref GattDescriptor Desc,
        [param: In] ref GattDescriptorValue Value);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void GattClientFreeMem(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr pMem);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern ClientState GattClientGetState(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(WclGattClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 GattClientWriteClientConfiguration(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr ClientClient,
        [param: In] ref GattCharacteristic Char,
        [param: MarshalAs(UnmanagedType.Bool), In] Boolean Subscribe,
        [param: In] GattOperationFlag Flag,
        [param: In] GattProtectionLevel Protection);
    #endregion

    // GATT Client instance.
    private IntPtr FClient;

    #region GATT client delegates
    private GATTCLIENT_CONNECT FOnConnect;
    private GATTCLIENT_DISCONNECT FOnDisconnect;
    private GATTCLIENT_ONCHANGED FOnChanged;
    #endregion

    #region GATT client callback handlers
    private void DoConnect(IntPtr sender, Int32 Error)
    {
        if (OnConnect != null)
            OnConnect(this, Error);
    }

    private void DoDisconnect(IntPtr sender, Int32 Reason)
    {
        if (OnDisconnect != null)
            OnDisconnect(this, Reason);
    }

    private void DoChanged(IntPtr sender, UInt16 Handle, IntPtr Value, UInt32 ValueLen)
    {
        if (OnChanged != null)
        {
            Byte[] v = null;
            if (Value != IntPtr.Zero && ValueLen > 0)
            {
                v = new Byte[ValueLen];
                Marshal.Copy(Value, v, 0, (int)ValueLen);
            }
            OnChanged(this, Handle, v);
        }
    }
    #endregion

    protected override void Free()
    {
        // Call close first if we did not do it yet.
        Disconnect();

        // Cleanup callbacks.
        GattClientSetOnChanged(FClient, null);
        GattClientSetOnConnect(FClient, null);
        GattClientSetOnDisconnect(FClient, null);

        // Dispose delegates.
        FOnConnect = null;
        FOnDisconnect = null;
        FOnChanged = null;

        // Delete Bluetooth Manager instance.
        GattClientDestroy(FClient);

        // And that's all
        FClient = IntPtr.Zero;
    }

    public GattClient()
        : base()
    {
        OnConnect = null;
        OnDisconnect = null;
        OnChanged = null;
        
        // Initialize callback delegates with its handlers.
        FOnConnect = new GATTCLIENT_CONNECT(DoConnect);
        FOnDisconnect = new GATTCLIENT_DISCONNECT(DoDisconnect);
        FOnChanged = new GATTCLIENT_ONCHANGED(DoChanged);
        
        // Create Bluetooth Manager instance...
        FClient = GattClientCreate();
        // ...and setup callbacks.
        GattClientSetOnChanged(FClient, FOnChanged);
        GattClientSetOnConnect(FClient, FOnConnect);
        GattClientSetOnDisconnect(FClient, FOnDisconnect);
    }

    #region GATT client methods
    public Int32 Connect(IntPtr Radio, Int64 Address)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return GattClientConnect(FClient, Radio, Address);
    }

    public Int32 Disconnect()
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return GattClientDisconnect(FClient);
    }

    public Int32 GetServices(out GattServices Services)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        Services = new GattServices();
        Services.Count = 0;
        Services.Services = new GattService[255];

        return GattClientGetServices(FClient, ref Services);
    }

    public Int32 GetCharacteristics(GattService Service, out GattCharacteristics Chars)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        Chars = new GattCharacteristics();
        Chars.Count = 0;
        Chars.Chars = new GattCharacteristic[255];

        return GattClientGetCharas(FClient, ref Service, ref Chars);
    }

    public Int32 GetDescriptors(GattCharacteristic Char, out GattDescriptors Descs)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        Descs = new GattDescriptors();
        Descs.Count = 0;
        Descs.Descs = new GattDescriptor[255];
        return GattClientGetDescriptors(FClient, ref Char, ref Descs);
    }

    public Int32 Subscribe(GattCharacteristic Char)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return GattClientSubscribe(FClient, ref Char);
    }

    public Int32 Unsubscribe(GattCharacteristic Char)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return GattClientUnsubscribe(FClient, ref Char);
    }

    public Int32 ReadValue(GattCharacteristic Char, out Byte[] Value)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        Value = null;

        IntPtr ppValue = IntPtr.Zero;
        UInt32 pSize = 0;
        Int32 Result = GattClientReadCharacteristicValue(FClient, ref Char, ref ppValue, ref pSize);
        if (Result == BluetoothErrors.WCL_E_SUCCESS && ppValue != IntPtr.Zero && pSize > 0)
        {
            Value = new Byte[pSize];
            Marshal.Copy(ppValue, Value, 0, (Int32)pSize);
            GattClientFreeMem(ppValue);
        }
        return Result;
    }

    public Int32 ReadDescriptorValue(GattDescriptor Desc, out GattDescriptorValue Value)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        Value = new GattDescriptorValue();
        return GattClientReadDescriptorValue(FClient, ref Desc, ref Value);
    }

    public Int32 WriteDescriptorValue(GattDescriptor Desc, GattDescriptorValue Value)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return GattClientWriteDescriptorValue(FClient, ref Desc, ref Value);
    }

    public Int32 WriteValue(GattCharacteristic Char, Byte[] Value)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        IntPtr pValue;
        try { pValue = Marshal.AllocHGlobal(Value.Length); } catch { pValue = IntPtr.Zero; }
        if (pValue == IntPtr.Zero)
            return BluetoothErrors.WCL_E_OUT_OF_MEMORY;

        Marshal.Copy(Value, 0, pValue, Value.Length);
        Int32 Res = GattClientWriteCharacteristicValue(FClient, ref Char, pValue, (UInt32)Value.Length);
        Marshal.FreeHGlobal(pValue);
        return Res;
    }

    public Int32 WriteClientConfiguration(GattCharacteristic Char, Boolean Subscribe,
        GattOperationFlag Flag, GattProtectionLevel Protection)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return GattClientWriteClientConfiguration(FClient, ref Char, Subscribe, Flag, Protection);
    }
    #endregion

    #region GATT client properties
    public ClientState State
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return GattClientGetState(FClient);
        }
    }
    #endregion

    #region GATT client events.
    public event ClietConnect OnConnect;
    public event ClientDisconnect OnDisconnect;
    public event ClientChanged OnChanged;
    #endregion
};